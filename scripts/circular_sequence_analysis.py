#!/usr/bin/env python3
"""
圓環序列分析

核心思想：
- 64卦形成一個圓環（文王序）
- 分析連續多卦的模式
- 類似 n-gram 分析

這類似於：
- DNA 圓環分析
- 循環碼（Cyclic codes）
- 環形圖論
"""

from collections import defaultdict

# 文王64卦序（完整）
KING_WEN_SEQUENCE = [
    (1, "111111"),   # 乾
    (2, "000000"),   # 坤
    (3, "010001"),   # 屯
    (4, "100010"),   # 蒙
    (5, "010111"),   # 需
    (6, "111010"),   # 訟
    (7, "000010"),   # 師
    (8, "010000"),   # 比
    (9, "110111"),   # 小畜
    (10, "111011"),  # 履
    (11, "000111"),  # 泰
    (12, "111000"),  # 否
    (13, "111101"),  # 同人
    (14, "101111"),  # 大有
    (15, "000100"),  # 謙
    (16, "001000"),  # 豫
    (17, "011001"),  # 隨
    (18, "100110"),  # 蠱
    (19, "000011"),  # 臨
    (20, "110000"),  # 觀
    (21, "101001"),  # 噬嗑
    (22, "100101"),  # 賁
    (23, "100000"),  # 剝
    (24, "000001"),  # 復
    (25, "111001"),  # 無妄
    (26, "100111"),  # 大畜
    (27, "100001"),  # 頤
    (28, "011110"),  # 大過
    (29, "010010"),  # 坎
    (30, "101101"),  # 離
    (31, "011100"),  # 咸
    (32, "001110"),  # 恆
    (33, "111100"),  # 遯
    (34, "001111"),  # 大壯
    (35, "101000"),  # 晉
    (36, "000101"),  # 明夷
    (37, "110101"),  # 家人
    (38, "101011"),  # 睽
    (39, "010100"),  # 蹇
    (40, "001010"),  # 解
    (41, "100011"),  # 損
    (42, "110001"),  # 益
    (43, "011111"),  # 夬
    (44, "111110"),  # 姤
    (45, "011000"),  # 萃
    (46, "000110"),  # 升
    (47, "011010"),  # 困
    (48, "010110"),  # 井
    (49, "011101"),  # 革
    (50, "101110"),  # 鼎
    (51, "001001"),  # 震
    (52, "100100"),  # 艮
    (53, "110100"),  # 漸
    (54, "001011"),  # 歸妹
    (55, "001101"),  # 豐
    (56, "101100"),  # 旅
    (57, "110110"),  # 巽
    (58, "011011"),  # 兌
    (59, "110010"),  # 渙
    (60, "010011"),  # 節
    (61, "110011"),  # 中孚
    (62, "001100"),  # 小過
    (63, "010101"),  # 既濟
    (64, "101010"),  # 未濟
]

# 我們的樣本數據
SAMPLES = [
    (1, 1, "111111", 0), (1, 2, "111111", 1), (1, 3, "111111", 0),
    (1, 4, "111111", 0), (1, 5, "111111", 1), (1, 6, "111111", -1),
    (2, 1, "000000", -1), (2, 2, "000000", 1), (2, 3, "000000", 0),
    (2, 4, "000000", 0), (2, 5, "000000", 1), (2, 6, "000000", -1),
    (3, 1, "010001", 0), (3, 2, "010001", 0), (3, 3, "010001", -1),
    (3, 4, "010001", 1), (3, 5, "010001", 0), (3, 6, "010001", -1),
    (4, 1, "100010", 0), (4, 2, "100010", 1), (4, 3, "100010", -1),
    (4, 4, "100010", -1), (4, 5, "100010", 1), (4, 6, "100010", 0),
    (5, 1, "010111", 0), (5, 2, "010111", 0), (5, 3, "010111", -1),
    (5, 4, "010111", -1), (5, 5, "010111", 1), (5, 6, "010111", 0),
    (6, 1, "111010", 0), (6, 2, "111010", 0), (6, 3, "111010", 0),
    (6, 4, "111010", 0), (6, 5, "111010", 1), (6, 6, "111010", -1),
    (15, 1, "000100", 1), (15, 2, "000100", 1), (15, 3, "000100", 1),
    (15, 4, "000100", 1), (15, 5, "000100", 0), (15, 6, "000100", 0),
    (17, 1, "011001", 0), (17, 2, "011001", -1), (17, 3, "011001", 0),
    (17, 4, "011001", 0), (17, 5, "011001", 1), (17, 6, "011001", 0),
    (20, 1, "110000", 0), (20, 2, "110000", 0), (20, 3, "110000", 0),
    (20, 4, "110000", 0), (20, 5, "110000", 0), (20, 6, "110000", 0),
    (24, 1, "000001", 1), (24, 2, "000001", 1), (24, 3, "000001", 0),
    (24, 4, "000001", 0), (24, 5, "000001", 0), (24, 6, "000001", -1),
    (25, 1, "111001", 1), (25, 2, "111001", 1), (25, 3, "111001", -1),
    (25, 4, "111001", 0), (25, 5, "111001", 0), (25, 6, "111001", -1),
    (33, 1, "111100", -1), (33, 2, "111100", 1), (33, 3, "111100", 0),
    (33, 4, "111100", 0), (33, 5, "111100", 1), (33, 6, "111100", 1),
    (47, 1, "011010", -1), (47, 2, "011010", 0), (47, 3, "011010", -1),
    (47, 4, "011010", 0), (47, 5, "011010", 0), (47, 6, "011010", 0),
    (50, 1, "101110", 0), (50, 2, "101110", 0), (50, 3, "101110", 0),
    (50, 4, "101110", -1), (50, 5, "101110", 1), (50, 6, "101110", 1),
    (63, 1, "010101", 1), (63, 2, "010101", 0), (63, 3, "010101", 0),
    (63, 4, "010101", 0), (63, 5, "010101", 0), (63, 6, "010101", -1),
]

# 卦名對照
HEX_NAMES = {
    1: "乾", 2: "坤", 3: "屯", 4: "蒙", 5: "需", 6: "訟",
    15: "謙", 17: "隨", 20: "觀", 24: "復", 25: "无妄",
    33: "遯", 47: "困", 50: "鼎", 63: "既濟"
}

TRIGRAM_TO_CHAR = {
    "000": "0", "001": "1", "010": "2", "011": "3",
    "100": "4", "101": "5", "110": "6", "111": "7",
}

def binary_to_word(binary):
    upper = binary[0:3]
    lower = binary[3:6]
    return TRIGRAM_TO_CHAR[upper] + TRIGRAM_TO_CHAR[lower]

print("=" * 70)
print("圓環序列分析：64卦形成的圓")
print("=" * 70)
print()

# ============================================================
# 1. 將64卦序列視覺化為圓
# ============================================================

print("64卦序列（文王序）：")
print("-" * 70)

# 顯示序列的前32卦
for i in range(0, 32, 4):
    row = ""
    for j in range(4):
        idx = i + j
        hex_num, binary = KING_WEN_SEQUENCE[idx]
        word = binary_to_word(binary)
        row += f" {hex_num:2}:{word} "
    print(row)

print("   ... (序號33-64) ...")
print()
print("→ 卦64 連接回 卦1，形成圓環")

# ============================================================
# 2. 分析我們樣本在圓環中的位置
# ============================================================

print()
print("=" * 70)
print("分析1：樣本在圓環中的位置分布")
print("=" * 70)
print()

# 找出我們有樣本的卦在序列中的位置
sample_hex_nums = list(set(s[0] for s in SAMPLES))
sample_positions = []

for i, (hex_num, binary) in enumerate(KING_WEN_SEQUENCE):
    if hex_num in sample_hex_nums:
        sample_positions.append((i, hex_num, HEX_NAMES.get(hex_num, "?")))

print("樣本卦在序列中的位置：")
for pos, hex_num, name in sample_positions:
    print(f"  位置 {pos+1:2}: 卦{hex_num:2} {name}")

# ============================================================
# 3. 分析相鄰卦的關係
# ============================================================

print()
print("=" * 70)
print("分析2：相鄰卦（bigram）的吉凶關係")
print("=" * 70)
print()

# 建立卦的吉凶統計
hex_fortune = {}
for hex_num, pos, binary, actual in SAMPLES:
    if hex_num not in hex_fortune:
        hex_fortune[hex_num] = {"ji": 0, "zhong": 0, "xiong": 0}
    if actual == 1:
        hex_fortune[hex_num]["ji"] += 1
    elif actual == 0:
        hex_fortune[hex_num]["zhong"] += 1
    else:
        hex_fortune[hex_num]["xiong"] += 1

# 分析相鄰卦
print("相鄰卦的吉凶傾向：")
print()

for i, (hex1_num, bin1) in enumerate(KING_WEN_SEQUENCE):
    if hex1_num in hex_fortune:
        next_idx = (i + 1) % 64
        prev_idx = (i - 1) % 64
        hex2_num, bin2 = KING_WEN_SEQUENCE[next_idx]
        hex0_num, bin0 = KING_WEN_SEQUENCE[prev_idx]

        word1 = binary_to_word(bin1)
        word0 = binary_to_word(bin0)
        word2 = binary_to_word(bin2)

        f = hex_fortune[hex1_num]
        tendency = "吉" if f["ji"] > f["xiong"] else ("凶" if f["xiong"] > f["ji"] else "中")

        print(f"  [{word0}] → [{word1}] → [{word2}]")
        print(f"  {HEX_NAMES.get(hex0_num, '?'):4} → {HEX_NAMES.get(hex1_num, '?'):4} → "
              f"{HEX_NAMES.get(hex2_num, '?'):4}")
        print(f"  卦{hex1_num} 傾向: {tendency} (吉{f['ji']} 中{f['zhong']} 凶{f['xiong']})")
        print()

# ============================================================
# 4. 分析卦序列位置與吉凶的關係
# ============================================================

print()
print("=" * 70)
print("分析3：序列位置（1-64）與吉凶")
print("=" * 70)
print()

# 將序列分為8個區段
segments = [
    (1, 8, "創始期"),    # 乾坤屯蒙需訟師比
    (9, 16, "發展期"),   # 小畜履泰否同人大有謙豫
    (17, 24, "轉變期"),  # 隨蠱臨觀噬嗑賁剝復
    (25, 32, "穩定期"),  # 无妄大畜頤大過坎離咸恆
    (33, 40, "退守期"),  # 遯大壯晉明夷家人睽蹇解
    (41, 48, "調整期"),  # 損益夬姤萃升困井
    (49, 56, "變革期"),  # 革鼎震艮漸歸妹豐旅
    (57, 64, "完成期"),  # 巽兌渙節中孚小過既濟未濟
]

print("各區段的吉凶分布：")
for start, end, name in segments:
    ji = 0
    zhong = 0
    xiong = 0
    count = 0

    for hex_num in range(start, end + 1):
        if hex_num in hex_fortune:
            f = hex_fortune[hex_num]
            ji += f["ji"]
            zhong += f["zhong"]
            xiong += f["xiong"]
            count += 1

    if count > 0:
        print(f"  {name} ({start:2}-{end:2}): 吉{ji:2} 中{zhong:2} 凶{xiong:2} (有{count}卦數據)")

# ============================================================
# 5. 圓環對稱性分析
# ============================================================

print()
print("=" * 70)
print("分析4：圓環對稱性")
print("=" * 70)
print()

# 分析對面位置（相距32）的卦
print("圓環對面位置的吉凶對比：")
for i, (hex1_num, bin1) in enumerate(KING_WEN_SEQUENCE[:32]):
    if hex1_num in hex_fortune:
        opposite_idx = i + 32
        hex2_num, bin2 = KING_WEN_SEQUENCE[opposite_idx]

        word1 = binary_to_word(bin1)
        word2 = binary_to_word(bin2)

        f1 = hex_fortune.get(hex1_num, {"ji": 0, "zhong": 0, "xiong": 0})
        f2 = hex_fortune.get(hex2_num, {"ji": 0, "zhong": 0, "xiong": 0})

        t1 = "吉" if f1["ji"] > f1["xiong"] else ("凶" if f1["xiong"] > f1["ji"] else "中")
        t2 = "吉" if f2["ji"] > f2["xiong"] else ("凶" if f2["xiong"] > f2["ji"] else "中")

        if hex2_num in hex_fortune:
            print(f"  位置 {i+1:2} ↔ {opposite_idx+1:2}: "
                  f"[{word1}]{HEX_NAMES.get(hex1_num, '?'):3}({t1}) ↔ "
                  f"[{word2}]{HEX_NAMES.get(hex2_num, '?'):3}({t2})")

# ============================================================
# 6. 變卦連接分析
# ============================================================

print()
print("=" * 70)
print("分析5：變卦連接（每爻變後的卦）")
print("=" * 70)
print()

def flip_line(binary, pos):
    b = list(binary)
    idx = 6 - pos
    b[idx] = '0' if b[idx] == '1' else '1'
    return ''.join(b)

def find_hex_by_binary(binary):
    for hex_num, b in KING_WEN_SEQUENCE:
        if b == binary:
            return hex_num
    return None

print("變卦連接圖（樣本卦每爻變後連接到哪卦）：")
print()

for hex_num in sorted(sample_hex_nums):
    binary = None
    for h, b in KING_WEN_SEQUENCE:
        if h == hex_num:
            binary = b
            break

    if binary:
        print(f"卦{hex_num:2} {HEX_NAMES.get(hex_num, '?'):4} [{binary_to_word(binary)}]:")
        for pos in range(1, 7):
            new_binary = flip_line(binary, pos)
            new_hex = find_hex_by_binary(new_binary)
            new_word = binary_to_word(new_binary)

            # 該爻的吉凶
            actual = None
            for s in SAMPLES:
                if s[0] == hex_num and s[1] == pos:
                    actual = s[3]
                    break

            actual_str = ["凶", "中", "吉"][actual + 1] if actual is not None else "?"

            if new_hex:
                print(f"    爻{pos}({actual_str}) → 卦{new_hex:2} {HEX_NAMES.get(new_hex, '?'):4} [{new_word}]")
            else:
                print(f"    爻{pos}({actual_str}) → [{new_word}]（未在樣本中）")
        print()

# ============================================================
# 總結
# ============================================================

print()
print("=" * 70)
print("圓環分析總結")
print("=" * 70)
print("""
關鍵發現：

1. 序列位置效應
   - 樣本集中在序列的前端（1-6）和中段（15-25, 47-50, 63）
   - 不同區段可能有不同的吉凶傾向

2. 相鄰卦關係
   - 相鄰卦形成「詞組」（bigram）
   - 前後文影響當前卦的吉凶

3. 圓環對稱性
   - 對面位置（相距32）的卦可能有對稱關係
   - 如：乾↔遯，坤↔大壯

4. 變卦連接
   - 每爻變化連接到特定的卦
   - 形成一個64節點的有向圖

下一步：
- 分析完整64卦的圓環模式
- 建立變卦連接圖
- 尋找圖論規律
""")
